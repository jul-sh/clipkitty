// ClipKitty Core FFI Definitions (UniFFI)
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ DEPENDENCY MAP - This file is the source of truth for FFI types            │
// │                                                                             │
// │ When you modify this file, update:                                          │
// │ 1. Run: cargo run --bin generate-bindings (regenerates Swift bindings)      │
// │ 2. Update: Sources/ClipKittyRustWrapper/ClipKittyRust.swift                 │
// │    - Add/update switch cases for enum changes                               │
// │    - Add Sendable conformance for new types                                 │
// │                                                                             │
// │ Rust implementations:                                                       │
// │   - models.rs: ClipboardItem, ClipboardContent, LinkMetadataState, etc.     │
// │   - store.rs: ClipboardStore methods                                        │
// │   - lib.rs: Namespace functions (is_url, detect_content_type, etc.)         │
// └─────────────────────────────────────────────────────────────────────────────┘

namespace clipkitty_core {
    // Content detection
    boolean is_url(string text);
    string detect_content_type(string text);
};

// ─────────────────────────────────────────────────────────────────────────────
// ICON TYPES
// ─────────────────────────────────────────────────────────────────────────────

// SF Symbol icon type for content categories
[Enum]
interface IconType {
    Text();
    Link();
    Email();
    Phone();
    Address();
    DateType();
    Transit();
    Image();
    Color();
};

// Icon representation - can be an SF Symbol, a color swatch, or a thumbnail
[Enum]
interface ItemIcon {
    Symbol(IconType icon_type);
    ColorSwatch(u32 rgba);
    Thumbnail(sequence<u8> bytes);
};

// ─────────────────────────────────────────────────────────────────────────────
// CONTENT TYPES
// ─────────────────────────────────────────────────────────────────────────────

// Link metadata fetch state
[Enum]
interface LinkMetadataState {
    Pending();
    Loaded(string? title, sequence<u8>? image_data);
    Failed();
};

// Content type with associated data
[Enum]
interface ClipboardContent {
    Text(string value);
    Color(string value);
    Link(string url, LinkMetadataState metadata_state);
    Email(string address);
    Phone(string number);
    Address(string value);
    Date(string value);
    Transit(string value);
    Image(sequence<u8> data, string description);
};

// ─────────────────────────────────────────────────────────────────────────────
// ITEM METADATA & MATCHES
// ─────────────────────────────────────────────────────────────────────────────

// Highlight range in text (start, end positions)
dictionary HighlightRange {
    u64 start;
    u64 end;
};

// Match context data - the text snippet, highlights, and line info
dictionary MatchData {
    string text;
    sequence<HighlightRange> highlights;
    u64 line_number;
};

// Lightweight item metadata for list display
dictionary ItemMetadata {
    i64 item_id;
    ItemIcon icon;
    string preview;
    string? source_app;
    string? source_app_bundle_id;
    i64 timestamp_unix;
};

// Search match: metadata + match context
dictionary ItemMatch {
    ItemMetadata item_metadata;
    MatchData match_data;
};

// ─────────────────────────────────────────────────────────────────────────────
// RESULT TYPES
// ─────────────────────────────────────────────────────────────────────────────

// Initial fetch result (no search query) - just metadata for display
dictionary FetchResults {
    sequence<ItemMetadata> items;
    u64 total_count;
    boolean has_more;
};

// Search result with matches (metadata + match highlights)
dictionary SearchResult {
    sequence<ItemMatch> matches;
    u64 total_count;
};

// Full clipboard item for preview pane
dictionary ClipboardItem {
    ItemMetadata item_metadata;
    ClipboardContent content;
    sequence<HighlightRange> preview_highlights;
};

// ─────────────────────────────────────────────────────────────────────────────
// ERROR TYPE
// ─────────────────────────────────────────────────────────────────────────────

[Error]
enum ClipKittyError {
    "DatabaseError",
    "IndexError",
    "NotInitialized",
    "InvalidInput",
};

// ─────────────────────────────────────────────────────────────────────────────
// MAIN STORE INTERFACE
// ─────────────────────────────────────────────────────────────────────────────

// Main store interface - thread-safe singleton
interface ClipboardStore {
    [Throws=ClipKittyError]
    constructor(string db_path);

    // Database info
    i64 database_size();
    boolean verify_fts_integrity();

    // Item operations
    [Throws=ClipKittyError]
    i64 save_text(string text, string? source_app, string? source_app_bundle_id);

    [Throws=ClipKittyError]
    i64 save_image(sequence<u8> image_data, string? source_app, string? source_app_bundle_id);

    [Throws=ClipKittyError]
    void update_link_metadata(i64 item_id, string? title, sequence<u8>? image_data);

    [Throws=ClipKittyError]
    void update_image_description(i64 item_id, string description);

    [Throws=ClipKittyError]
    void update_timestamp(i64 item_id);

    [Throws=ClipKittyError]
    void delete_item(i64 item_id);

    [Throws=ClipKittyError]
    void clear_all();

    [Throws=ClipKittyError]
    u64 prune_to_size(i64 max_bytes, f64 keep_ratio);

    // Fetch items for initial display (no query) - returns lightweight metadata
    [Throws=ClipKittyError]
    FetchResults fetch_items(i64? before_timestamp_unix, u64 limit);

    // Search - returns matches with metadata and highlights
    [Throws=ClipKittyError]
    SearchResult search(string query);

    // Fetch full items by IDs for preview pane (with optional search query for highlights)
    [Throws=ClipKittyError]
    sequence<ClipboardItem> fetch_by_ids(sequence<i64> ids, string? search_query);
};
