// ClipKitty Core FFI Definitions (UniFFI)
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ DEPENDENCY MAP - This file is the source of truth for FFI types            │
// │                                                                             │
// │ When you modify this file, update:                                          │
// │ 1. Run: cargo run --bin generate-bindings (regenerates Swift bindings)      │
// │ 2. Update: Sources/ClipKittyRustWrapper/ClipKittyRust.swift                 │
// │    - Add/update switch cases for enum changes                               │
// │    - Add Sendable conformance for new types                                 │
// │                                                                             │
// │ Rust implementations:                                                       │
// │   - models.rs: ClipboardItem, ClipboardContent, LinkMetadataState, etc.     │
// │   - store.rs: ClipboardStore methods                                        │
// │   - lib.rs: Namespace functions (is_url, detect_content_type, etc.)         │
// └─────────────────────────────────────────────────────────────────────────────┘

namespace clipkitty_core {
    // Content detection
    boolean is_url(string text);
    string detect_content_type(string text);
    sequence<sequence<u64>> highlight_ranges(string text, string query);
};

// Link metadata fetch state
[Enum]
interface LinkMetadataState {
    Pending();
    Loaded(string? title, sequence<u8>? image_data);
    Failed();
};

// Content type with associated data
[Enum]
interface ClipboardContent {
    Text(string value);
    Link(string url, LinkMetadataState metadata_state);
    Email(string address);
    Phone(string number);
    Address(string value);
    Date(string value);
    Transit(string value);
    Image(sequence<u8> data, string description);
};

// Clipboard item
dictionary ClipboardItem {
    i64? id;
    ClipboardContent content;
    string content_hash;
    i64 timestamp_unix;
    string? source_app;
    string? source_app_bundle_id;
};

// Highlight range in text (start, end positions)
dictionary HighlightRange {
    u32 start;
    u32 end;
};

// A search match with item ID and highlight ranges
dictionary SearchMatch {
    i64 item_id;
    sequence<HighlightRange> highlights;
    record<DOMString, string> debug_info;
};

// Search result with matches (IDs + highlights)
dictionary SearchResult {
    sequence<SearchMatch> matches;
    u64 total_count;
};

// Fetch result with pagination info
dictionary FetchResult {
    sequence<ClipboardItem> items;
    boolean has_more;
};

// Error types
[Error]
enum ClipKittyError {
    "DatabaseError",
    "IndexError",
    "NotInitialized",
    "InvalidInput",
};

// Main store interface - thread-safe singleton
interface ClipboardStore {
    [Throws=ClipKittyError]
    constructor(string db_path);

    // Database info
    i64 database_size();
    boolean verify_fts_integrity();

    // Item operations
    [Throws=ClipKittyError]
    i64 save_text(string text, string? source_app, string? source_app_bundle_id);

    [Throws=ClipKittyError]
    i64 save_image(sequence<u8> image_data, string? source_app, string? source_app_bundle_id);

    [Throws=ClipKittyError]
    void update_link_metadata(i64 item_id, string? title, sequence<u8>? image_data);

    [Throws=ClipKittyError]
    void update_image_description(i64 item_id, string description);

    [Throws=ClipKittyError]
    void update_timestamp(i64 item_id);

    [Throws=ClipKittyError]
    void delete_item(i64 item_id);

    [Throws=ClipKittyError]
    void clear_all();

    [Throws=ClipKittyError]
    u64 prune_to_size(i64 max_bytes, f64 keep_ratio);

    // Fetch with pagination
    [Throws=ClipKittyError]
    FetchResult fetch_items(i64? before_timestamp_unix, u64 limit);

    // Search - returns IDs + highlight ranges (Swift caches items)
    [Throws=ClipKittyError]
    SearchResult search(string query);

    // Fetch items by IDs (for cache misses)
    [Throws=ClipKittyError]
    sequence<ClipboardItem> fetch_by_ids(sequence<i64> ids);
};
